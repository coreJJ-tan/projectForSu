1、概念
	广义表，又称列表（与python中了列表概念一样），	是一种线性存储结构。同数组类似，广义表中既可以存储不可再分的元素，也可以存储广义表，记作：
	LS = (a1,a2,…,an)
	其中，LS 代表广义表的名称，an 表示广义表存储的数据。广义表中每个 ai 既可以代表单个元素，也可以代表另一个广义表。

2、广义表的原子和子表
	通常，广义表中存储的单个元素称为 "原子"，而存储的广义表称为 "子表"。
	例如创建一个广义表 LS = {1,{1,2,3}}，我们可以这样解释此广义表的构成：广义表 LS 存储了一个原子 1 和子表 {1,2,3}。
	以下是广义表存储数据的一些常用形式：
	A = ()：A 表示一个广义表，只不过表是空的。
	B = (e)：广义表 B 中只有一个原子 e。
	C = (a,(b,c,d)) ：广义表 C 中有两个元素，原子 a 和子表 (b,c,d)。
	D = (A,B,C)：广义表 D 中存有 3 个子表，分别是A、B和C。这种表示方式等同于 D = ((),(e),(b,c,d)) 。
	E = (a,E)：广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：E = (a,(a,(a,…)))。

	注意，A = () 和 A = (()) 是不一样的。前者是空表，而后者是包含一个子表的广义表，只不过这个子表是空表。
	
3、广义表的表头和表尾
	当广义表不是空表时，称第一个数据（原子或子表）为"表头"，剩下的数据构成的新广义表为"表尾"。
	强调一下，除非广义表为空表，否则广义表一定具有表头和表尾，且广义表的表尾一定是一个广义表。
	例如在广义表中 LS={1,{1,2,3},5} 中，表头为原子 1，表尾为子表 {1,2,3} 和原子 5 构成的广义表，即 {{1,2,3},5}。
	再比如，在广义表 LS = {1} 中，表头为原子 1 ，但由于广义表中无表尾元素，因此该表的表尾是一个空表，用 {} 表示。
	
4、广义表的存储结构
	由于广义表中既可存储原子（不可再分的数据元素），也可以存储子表，因此很难使用顺序存储结构表示，通常情况下广义表结构采用链表实现。
	使用链表存储广义表，首先需要确定链表中节点的结构。由于广义表中可同时存储原子和子表两种形式的数据，因此链表节点的结构也有两种：
	（1）	| tag=0 | atom |
	（2）	| tag=1 || hp | tp |
	如上，表示原子的节点由两部分构成，分别是 tag 标记位和原子的值，表示子表的节点由三部分构成，分别是 tag 标记位、hp 指针和 tp 指针。
	tag 标记位用于区分此节点是原子还是子表，通常原子的 tag 值为 0，子表的 tag 值为 1。
	子表节点中的 hp 指针指向当前节点表示的子表，tp 指针指向当前广义表的下一个节点。

5、广义表中两种节点的C语言表示代码
typedef struct GLNode{
    int tag;//标志域
    union{
        char atom;//原子结点的值域
        struct{
            struct GLNode * hp,*tp;
        }ptr;//子表结点的指针域，hp指向表头；tp指向表尾（注意上面对表头和表尾概念的解释）
    }subNode;
}*Glist;
	这里用到了 union 共用体，因为同一时间此节点不是原子节点就是子表节点，当表示原子节点时，就使用 atom 变量；反之则使用 ptr 结构体。
	自己的理解：广义表本身就使用这个结构体描述，用这个存储结构创建广义表，其实就是不断地创建表头的过程。

6、广义表的另一种存储结构
	（1）	| tag=0 | atom | tp |		// 比起上一种存储结构，此处多了一个 tp 指针
	（2）	| tag=1 || hp | tp |
用 C 语言代码表示为：
typedef struct GNode {
    int tag;//标志域
    union {
        int atom;//原子结点的值域
        struct GNode* hp;//子表结点的指针域，hp指向表头
    }subNode;
    struct GNode* tp;//这里的tp相当于链表的next指针，用于指向下一个数据元素
}GLNode, *Glist;
	自己的理解：广义表本身就使用这个结构体描述抛开hp指针，仅由tp指针看，便是一个单向非循环链表，链接着广义表的所有一级节点

无论采用以上哪一种节点结构存储广义表，都不要破坏广义表中各数据元素之间的并列关系。拿 {a,{b,c,d}} 来说，原子 a 和子表 {b,c,d} 是并列的，
而在子表 {b,c,d} 中原子 b、c、d 是并列的。（理解这个尤为重要）
	自己的理解：个人倾向于第二种，第一种用起来绕

7、广义表的深度和长度
	如下的算法均使用第一种存储结构的算法
7.1 广义表的长度
	广义表的长度，指的是广义表中所包含的数据元素的个数。（对应于python中的列表长度）
C语言判断广义表的长度：
int GlistLength(Glist C){
    int Number=0;
    Glist P=C;
    while(P){
        Number++;
        P=P->ptr.tp;
    }
    return Number;
}


7.2 广义表的深度
	广义表的深度，可以通过观察该表中所包含括号的层数间接得到。
	个人理解：广义表的深度意义为从表头开始，需要获取多少次hp指针才能获取到相应节点的最大值
C语言计算广义表的深度：
int GlistDepth(Glist C){
    //如果表C为空表时，直接返回长度1；
    if (!C) {
        return 1;
    }
    //如果表C为原子时，直接返回0；
    if (C->tag==0) {
        return 0;
    }
    int max=0;//设置表C的初始长度为0；
    for (Glist pp=C; pp; pp=pp->ptr.tp) {
        int dep=GlistDepth(pp->ptr.hp);		// 使用递归方式
        if (dep>max) {
            max=dep;//每次找到表中遍历到深度最大的表，并用max记录
        }
    }
    //程序运行至此处，表明广义表不是空表，由于原子返回的是0，而实际长度是1，所以，此处要+1；
    return max+1;
}

8、广义表的复制
	针对第一种存储结构，对于任意一个非空广义表来说，都是由两部分组成：表头和表尾。反之，只要确定的一个广义表的表头和表尾，那么这个广义表就可
以唯一确定下来。复制一个广义表，也是不断的复制表头和表尾的过程。如果表头或者表尾同样是一个广义表，依旧复制其表头和表尾。所以，复制广义表的过
程，其实就是不断的递归，复制广义表中表头和表尾的过程。
C语言实现：
void copyGlist(Glist C, Glist *T){
    //如果C为空表，那么复制表直接为空表 
    if (!C) {
        *T=NULL;
    }
    else{
        *T=(Glist)malloc(sizeof(GNode));//C不是空表，给T申请内存空间
        //申请失败，程序停止
        if (!*T) {
            exit(0);
        }
        (*T)->tag=C->tag;//复制表C的tag值
        //判断当前表元素是否为原子，如果是，直接复制
        if (C->tag==0) {
            (*T)->atom=C->atom;
        }else{//运行到这，说明复制的是子表
            copyGlist(C->ptr.hp, &((*T)->ptr.hp));//复制表头
            copyGlist(C->ptr.tp, &((*T)->ptr.tp));//复制表尾
        }
    }
}

9、广义表插入节点，删除节点